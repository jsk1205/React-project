##### 样式
	background-size: cover;

#####　校验:密码和用户名
1>自定义校验:validator (rule, value) => Promise
if(!(/^\w+$/).test(value)) MsgArr.push('密码必须是英文、数字、下划线组成！')
2>声明式校验:form下的item写rules 时 username,password必须有名字 如:<item name="username"></item> 而且name 写在Item 里面
rules={[ {} ]} rules是规则,规则里面的每一项是对象

3>当什么都不输入的情况下直接点login 会有问题(自定义校验时)
Cannot read property 'trim' of undefined
什么都不输入直接点击login,此时底层已经校验了拿到的不是空值,而是undefined,所以来个形参默认值 :value=''

##### 收集表单的数据
<Form onFinish={this.onFinish} >
onFinish = values=>{//表单 提交 且 验证 通过 的 回调-->
    //自动收集表单里面的数据(里面的每一项,都有个名字,通过此来收集数据)并形成key-value的组合包装成对象,即values
    console.log('Received values of form: ', values);
  }
antd  单页面提交 只是做了 提交 的动作 并没有调 onFinish
只是把数据展示出来

##### 使用请求体参数 
post请求:query/params 这两种都不考虑
使用请求体参数body:json /urlencoded
post->body->raw(原始的)->json:json格式
##### 配置代理解决跨域
1>配置代理后,请求成功而data里面数据错误
原因是参数形式错误,不是请求头 即content-type
如果发生请求的时候用axios,里面传的参数 第二个为对象,他在底层直接调对象,而json身上有个stringify,即把你传的对象转成了字符串,但服务器不认
我们需要带urlencoded格式,那么我们可以自己拼然后传过去
即axios.post(path,`username=$(values.username)&password=${values,.password}`)
2>(a:1,b:2)==>'a=1,b=2' ?  需要用到querystring 就可以把对象转换成urlencoded编码
3>axios 请求拦截器
axios.interceptors.request.use((config)=>{
      //console.log(config)//config里面的data此时还未转换为json格式 即data :Object

##### redux
1>是什么?
  a.做状态管理的js库 不是react插件库
  b.可以与react配合使用,可以用在react,angular,vue等项目
  c.集中式管理(读/更新) react应用中多个组件共享的状态
2>流程
  1>>何时调用reducer:1+n(也在reducer里面初始化原始数据)
  2>>移除组件 状态,及操作状态的方法
  yarn add redux
  3>>创建store核心对象,同时指定好为store服务的reducer(本身是个函数)
  然后 redux->store.js并暴露
  import {createStore} from 'redux'
  import countReducer from './countReducer'
  let store=createStore(countReducer)
  export default store

  //countReducer--->Reducers加工完状态给store了
  let initStat=0
  function countReducer(preState=initState,action){
    const {type,data}=action
    let newState
    switch(type):
          case 'increment':
          newState= preState+date
          return newState;
          case 'decrement': newState=preState-date
          return newState;
          default : return preState//不加也不减
  }

  //count.jsx
  import store from '../../redux/store'
  当前求和为 {store.getState()}
  //通知redux加value
  store.dispatch()

  //index.js  即组件和redux(说的算话的人 store)建立联系
  import store from './redux/store'
  //驱动页面
  getState() --:读
  dispatch() --:更新
  store.subscribe()//如果redux保存的状态发生变化,那么就调用store.subscribe所指定的回调
  //原始写法
  ReactDOM.render(<App/>,document.getElementById('root'))
  store.subscribe(()=>{
    ReactDOM.render(<App/>,document.getElementById('root'))
  })

  DOM
  App render()//重新调用render生成新的 虚拟dom,不代表整个页面都会刷新,因为dom的diff算法在那看着哪
  count render()//亦是如此

##### redux完整版

##### 对组件的分类
 1>按组件分 :一般组件
            路由组件
 2>按react-redux分:
            UI组件
            容器组件
 3>模型
 a.所有的UI组件都应该包裹一个容器组件,他们是父子关系
 b.容器组件是真正和redux打交道的,里面可以随意的使用redux的api
 c.UI组件中不能使用任何redux的api
 d.容器组件会传给UI组件:1>>redux中所保存的状态
                      2>>用于操作状态的方法
 e.容器与UI之间的传递:状态,操作状态的方法,均通过props传递

 ##### react-redux
 yarn add react-redux
 containers->Count.jsx //容器组件
 容器组件 肯定是组件,不是你亲自去定义的而是靠函数生成的
1>引入UI组件 
2>引入一个方法 connnect() 
  这个方法在 react-redux 身上
  即 import {connect} from 'react-redux'
  1>>.connect()的返回值依然是一个函数
  2>>.connect()() 的返回值是一个容器组件
  3>>.connect使用的方法是:connect(状态,操作状态的方法)(UI组件)
3>暴露 export default connect(状态,操作状态的方法)(Count)
4>在App.js里面渲染 containers/Count(App中渲染的不再是UI的count了)-->会报错
5>在index.js里面引入 react-redux 
import {Provider} from 'react-redux'
ReactDOM.render(
<Provider store={store}>
 <BrowserRouter>
  <App/>
 </BrowserRouter>
</Provider>,document.getElementById('root'))
报错就会消失,底层(react-redux)会调用
4.10
容器组件->UI组件:向ui组件传递
  1>mapStateToProps()用于给UI组件传递redux中的状态,以props形式传递
    1>>因为 props是key-value的形式,所以mapStateToProps方法必须返回一个object对象
    2>>mapStateToProps方法所返回的那个对象的key就作为传给UI组件props的key
    3>>mapStateToProps方法所返回的value亦是如此
  2>mapDispatchToProps()用于给UI组件传递redux中的操作状态的方法,以props形式
  3>mapStateToProps和mapDispatchToProps都是函数,

##### 流程
1.登录结果的提示+进度条
2.若登录成功，跳转到：/admin
3.搭建项目的redux环境（参考redux教学中最后一个版本）
4.登录成功后-->路由跳转,把用户信息 保 存 到redux(login)中去

export default connect(
   ()=>{},
  {saveUserInfo}//操作状态的方法
)(Login)
store.js->action_type.js->reducer.login.js->reducer.index.js->action.login.js
5.Admin组件 读 取 用户名展示
export default connect(
  state=>({//读取信息
    username:state.userInfo.user.username
  }),
  {}
)(Admin)
6.处理刷新页面redux信息丢失的问题---localstorage
//login
this.props.saveUserInfo(data)//存入用户信息同时也存入到localstorage(处理刷新页面redux信息丢失)
//redux->action
//向localstorage中保存当前登录的用户信息(字符串)
const {user,token} = userObj
localStorage.setItem('user',JSON.stringify(user)) //字符串存进去
localStorage.setItem('token',token)
//reducer->login.js
//读取localstorage
let _user=JSON.parse(localStorage.getItem('user'))//在对象形式读出来
let _token=localStorage.getItem('token')
然后判断里面是否有值
此时 私自篡改token/user 里面的值 (即里面的东西不合情不合理),也依然会正常显示-->即有bug
可以用一个 try catch 来处理
7.维护isLogin标识用户是否登录
redux所保存的 user以及token都有值,也都合法即正确的登录状态
即 hava 的问题  合法的问题
思考:
1>>localStorage.getItem('demo')若demo根本不存在,获取到的值是 null
2>>JSON.parse(localStorage.getItem('demo'))若demo根本不存在.parse转换后的值是 null

8.给Login组件和Admin组件增加权限的校验
利用 isLogin:state.userInfo.isLogin
Login组件:只有没登录只能看Login
if(this.props.isLogin)  return <Redirect to="/admin"/>
Admin组件:只有登录了才能看到,否则跳转到Login
 if (!this.props.isLogin) return <Redirect to="/login"/>
  //this.props.history适用于在非render函数中跳转
	//<Redirect>适用于在render函数中做跳转

之退出登录:
删除redux 即localstorage里面的数据
DELE_USERINFO
localStorage.clear()
9.Header组件-静态
10.Header组件-全屏，使用screenfull
利用钩子来检测屏幕的变化
screenfull.toggle(); //切换全屏
此时 f11 键时 全屏图标没有切换
页签全名:程序员可以用代码操作
浏览器全屏:只能借助f11(或浏览器快捷键)
因为f11 是浏览器上的
 componentDidMount(){ //onchage()
    //检测屏幕的变化
    screenfull.onchange(()=>{
      const {isFull}=this.state
      this.setState({isFull:!isFull})
    })
  }

11.Header组件-退出登录

createStore,applyMiddleware-->redux
Provider-->react-redux
combineReducers-->redux